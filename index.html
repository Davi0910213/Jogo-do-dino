<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Block Dash - Dino & Cacto com Pause e Ranking</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background-color: #222;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    height: 100vh;
    font-family: Arial, sans-serif;
  }
  #game {
    position: relative;
    width: 900px;
    height: 300px;
    background-color: #444;
    overflow: hidden;
    border: 2px solid #fff;
  }
  #player {
    position: absolute;
    bottom: 40px;
    left: 80px;
    width: 50px;
    height: 50px;
    z-index: 10;
  }
  #player svg {
    width: 100%;
    height: 100%;
    shape-rendering: crispEdges;
  }
  .obstacle {
    position: absolute;
    bottom: 40px;
    width: 50px;
    height: 50px;
    z-index: 10;
  }
  .obstacle svg {
    width: 100%;
    height: 100%;
    shape-rendering: crispEdges;
  }
  #score {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-size: 24px;
    z-index: 20;
  }
  #startButton, #pauseButton {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 15px 30px;
    font-size: 20px;
    cursor: pointer;
    border: none;
    border-radius: 8px;
    background-color: #0a0;
    color: white;
    z-index: 30;
  }
  #pauseButton {
    top: 15px;
    left: auto;
    right: 15px;
    transform: none;
    display: none;
    background-color: #cc0000;
  }
  #ranking {
    position: absolute;
    top: 50px;
    right: 15px;
    color: white;
    font-size: 18px;
    z-index: 20;
    background: rgba(0, 0, 0, 0.5);
    padding: 8px;
    border-radius: 5px;
    max-width: 200px;
  }
  #ranking ol {
    padding-left: 20px;
    margin: 5px 0 0 0;
  }
</style>
</head>
<body>

<div id="game">
  <div id="score">Score: 0</div>
  
  <div id="player">
    <!-- Dinossauro pixel art -->
    <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges">
      <!-- Corpo -->
      <rect x="15" y="25" width="30" height="20" fill="#4CAF50" />
      <!-- Cabeça -->
      <rect x="10" y="20" width="10" height="15" fill="#4CAF50" />
      <!-- Olho -->
      <rect x="16" y="23" width="3" height="3" fill="#000" />
      <!-- Perna traseira -->
      <rect x="20" y="45" width="8" height="10" fill="#388E3C" />
      <!-- Perna dianteira -->
      <rect x="35" y="45" width="8" height="10" fill="#388E3C" />
      <!-- Cauda -->
      <rect x="45" y="30" width="10" height="5" fill="#4CAF50" />
      <rect x="55" y="25" width="5" height="5" fill="#4CAF50" />
    </svg>
  </div>

  <!-- Obstáculos dinâmicos -->
  <div id="obstacles">
    <!-- Obstáculos serão gerados aqui pelo JavaScript -->
  </div>

  <button id="startButton">Começar Jogo</button>
  <button id="pauseButton">Pausar</button>

  <!-- Ranking -->
  <div id="ranking">
    <strong>Top Scores:</strong>
    <ol id="rankList">
      <!-- Lista será preenchida via JS -->
    </ol>
  </div>
</div>

<script>
  const player = document.getElementById('player');
  const obstaclesContainer = document.getElementById('obstacles');
  const scoreDisplay = document.getElementById('score');
  const startButton = document.getElementById('startButton');
  const pauseButton = document.getElementById('pauseButton');

  const gameWidth = 900;
  const groundLevel = 40;
  const playerLeft = 80;
  const playerWidth = 50;
  const playerHeight = 50;
  const obstacleWidth = 50;
  const obstacleHeight = 50;

  // Aumento das hitboxes para o jogador
  const playerHitbox = { width: 40, height: 45 };  
  const obstacleHitbox = { width: 30, height: 40 };

  let isJumping = false;
  let jumpHeight = 0;
  let jumpSpeed = 0;
  const gravity = 0.7;

  let obstacleSpeed = 6;
  let obstacles = [];
  let score = 0;
  let gameOver = false;
  let gameStarted = false;
  let paused = false;
  let animationFrameId;

  // Ranking com localStorage
  let topScores = JSON.parse(localStorage.getItem('blockDashTopScores')) || [];

  function updateRanking(score) {
    topScores.push(score);
    topScores = topScores.sort((a,b) => b - a).slice(0,5);
    localStorage.setItem('blockDashTopScores', JSON.stringify(topScores));
    renderRanking();
  }

  function renderRanking() {
    const rankList = document.getElementById('rankList');
    rankList.innerHTML = '';
    if(topScores.length === 0) {
      rankList.innerHTML = '<li>Nenhum score ainda</li>';
      return;
    }
    topScores.forEach(score => {
      const li = document.createElement('li');
      li.textContent = score;
      rankList.appendChild(li);
    });
  }

  // Função para gerar novos obstáculos
  function createObstacle() {
    const obstacle = document.createElement('div');
    obstacle.classList.add('obstacle');
    obstacle.style.left = gameWidth + 'px';
    obstaclesContainer.appendChild(obstacle);

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('viewBox', '0 0 64 64');
    svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    svg.setAttribute('shape-rendering', 'crispEdges');

    // Desenho do cacto
    const base = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    base.setAttribute('x', 20);
    base.setAttribute('y', 35);
    base.setAttribute('width', 24);
    base.setAttribute('height', 15);
    base.setAttribute('fill', '#D32F2F');
    svg.appendChild(base);

    const trunk = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    trunk.setAttribute('x', 28);
    trunk.setAttribute('y', 15);
    trunk.setAttribute('width', 8);
    trunk.setAttribute('height', 20);
    trunk.setAttribute('fill', '#D32F2F');
    svg.appendChild(trunk);

    obstacle.appendChild(svg);

    return obstacle;
  }

  function jump() {
    if (!isJumping && !paused) {
      isJumping = true;
      jumpSpeed = 12;  
    }
  }

  function keyHandler(e) {
    if (!gameStarted || paused) return;
    if ((e.code === 'ArrowUp' || e.key.toLowerCase() === 'w') && !gameOver) {
      jump();
    }
  }

  startButton.addEventListener('click', () => {
    gameStarted = true;
    startButton.style.display = 'none';
    pauseButton.style.display = 'block';
    window.addEventListener('keydown', keyHandler);
    update();
  });

  pauseButton.addEventListener('click', () => {
    if (!paused) {
      paused = true;
      pauseButton.textContent = 'Retomar';
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
    } else {
      paused = false;
      pauseButton.textContent = 'Pausar';
      update();
    }
  });

  function update() {
    if (gameOver || !gameStarted || paused) return;

    if (isJumping) {
      jumpHeight += jumpSpeed;
      jumpSpeed -= gravity;

      if (jumpHeight <= 0) {
        jumpHeight = 0;
        isJumping = false;
      }
    }

    player.style.bottom = groundLevel + jumpHeight + 'px';

    obstacles.forEach((obstacle, index) => {
      let pos = parseInt(obstacle.style.left) - obstacleSpeed;
      if (pos < -obstacleWidth) {
        obstacle.style.left = gameWidth + 'px';
        score++;
        scoreDisplay.textContent = 'Score: ' + score;

        if (score % 10 === 0 && obstacles.length < 5) {  
          obstacles.push(createObstacle());
        }
      } else {
        obstacle.style.left = pos + 'px';
      }

      // Verifica colisão com as hitboxes ajustadas
      const playerHitboxX = playerLeft + (playerWidth - playerHitbox.width) / 2;
      const playerHitboxY = groundLevel + jumpHeight;
      const obstacleHitboxX = parseInt(obstacle.style.left) + (obstacleWidth - obstacleHitbox.width) / 2;
      const obstacleHitboxY = groundLevel;

      const horizontalOverlap =
        playerHitboxX < obstacleHitboxX + obstacleHitbox.width &&
        playerHitboxX + playerHitbox.width > obstacleHitboxX;

      const verticalOverlap =
        playerHitboxY < obstacleHitboxY + obstacleHitbox.height &&
        playerHitboxY + playerHitbox.height > obstacleHitboxY;

      if (horizontalOverlap && verticalOverlap) {
        gameOver = true;
        updateRanking(score);  // Atualiza o ranking com o score
        alert('Game Over! Seu score: ' + score);
        location.reload();
      }
    });

    animationFrameId = requestAnimationFrame(update);
  }

  renderRanking();  // Exibe o ranking ao iniciar
</script>

</body>
</html>
